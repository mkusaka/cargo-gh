use anyhow::{Context, Result};
use std::fs;
use std::path::{Path, PathBuf};
use std::io::{self, Write};

const RELEASE_WORKFLOW_TEMPLATE: &str = r#"name: Release

on:
  push:
    tags:
      - 'v*'       # SemVer
      - '[0-9a-f]*' # Short-hash tags

permissions:
  contents: write  # For release creation and asset upload

jobs:
  # Linux builds
  release-linux:
    name: Release (Linux)
    runs-on: ubuntu-latest

    steps:
      - name: Checkout source
        uses: actions/checkout@v4

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: x86_64-unknown-linux-gnu,aarch64-unknown-linux-gnu

      - name: Install cross-compilation tools
        run: |
          sudo apt-get update
          sudo apt-get install -y gcc-aarch64-linux-gnu

      - name: Build cargo-ghdist
        run: |
          cargo build --release --bin cargo-ghdist
          cp target/release/cargo-ghdist ~/.cargo/bin/ || true

      - name: Run cargo-ghdist (Linux)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG=${GITHUB_REF#refs/tags/}
          cargo ghdist \
            --tag "$TAG" \
            --targets x86_64-unknown-linux-gnu,aarch64-unknown-linux-gnu \
            --format tgz

  # macOS builds
  release-macos:
    name: Release (macOS)
    runs-on: macos-latest

    steps:
      - name: Checkout source
        uses: actions/checkout@v4

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: x86_64-apple-darwin,aarch64-apple-darwin

      - name: Build cargo-ghdist
        run: |
          cargo build --release --bin cargo-ghdist
          cp target/release/cargo-ghdist ~/.cargo/bin/ || true

      - name: Run cargo-ghdist (macOS)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG=${GITHUB_REF#refs/tags/}
          cargo ghdist \
            --tag "$TAG" \
            --targets x86_64-apple-darwin,aarch64-apple-darwin \
            --format tgz
"#;

const GHDIST_CONFIG_TEMPLATE: &str = r#"# cargo-ghdist configuration file
# Generated by cargo ghdist init

# Default build profile
profile = "release"

# Default archive format
format = "tgz"

# Default targets to build
targets = [
    "x86_64-unknown-linux-gnu",
    "aarch64-unknown-linux-gnu",
    "x86_64-apple-darwin",
    "aarch64-apple-darwin",
]

# Skip cargo publish by default
skip_publish = true

# Generate checksums by default
generate_checksum = true

# Repository information (if not in Cargo.toml)
# [repository]
# owner = "your-username"
# repo = "your-repo"

# Binaries to include (if not specified, includes all)
# bins = []

# CI configuration
[ci]
provider = "github"
workflow_path = ".github/workflows/release.yml"
"#;

pub struct Initializer {
    yes: bool,
    ci_provider: String,
    skip_ci: bool,
}

impl Initializer {
    pub fn new(yes: bool, ci: String, skip_ci: bool) -> Self {
        Self {
            yes,
            ci_provider: ci,
            skip_ci,
        }
    }

    pub async fn run(&self) -> Result<()> {
        println!("ðŸš€ Initializing cargo-ghdist for your project...\n");

        // Check if we're in a Rust project
        if !Path::new("Cargo.toml").exists() {
            anyhow::bail!("No Cargo.toml found. Please run this command from a Rust project root.");
        }

        // Parse Cargo.toml for basic info
        let cargo_toml = fs::read_to_string("Cargo.toml")?;
        let manifest: toml::Value = toml::from_str(&cargo_toml)?;

        // Extract package info
        let package_name = manifest
            .get("package")
            .and_then(|p| p.get("name"))
            .and_then(|n| n.as_str())
            .unwrap_or("unknown");

        println!("ðŸ“¦ Found package: {}", package_name);

        // Create .config directory if it doesn't exist
        let config_dir = PathBuf::from(".config");
        if !config_dir.exists() {
            fs::create_dir_all(&config_dir)?;
            println!("ðŸ“ Created .config directory");
        }

        // Generate ghdist config
        let config_path = config_dir.join("ghdist.toml");
        if config_path.exists() && !self.yes {
            if !self.confirm("Configuration file already exists. Overwrite?")? {
                println!("â­ï¸  Skipping config file generation");
            } else {
                self.write_config(&config_path)?;
            }
        } else if !config_path.exists() {
            self.write_config(&config_path)?;
        }

        // Add build profile to Cargo.toml
        self.update_cargo_toml(&cargo_toml)?;

        // Generate CI workflow if requested
        if !self.skip_ci && self.ci_provider == "github" {
            self.generate_github_workflow()?;
        }

        // Show next steps
        println!("\nâœ… Initialization complete!");
        println!("\nðŸ“ Next steps:");
        println!("  1. Review and customize .config/ghdist.toml");
        if !self.skip_ci {
            println!("  2. Review .github/workflows/release.yml");
            println!("  3. Set up GITHUB_TOKEN secret in your repository settings");
        }
        println!("  4. Create a git tag: git tag v0.1.0");
        println!("  5. Push the tag: git push origin v0.1.0");
        println!("  6. cargo ghdist will automatically build and release!");

        Ok(())
    }

    fn write_config(&self, path: &Path) -> Result<()> {
        fs::write(path, GHDIST_CONFIG_TEMPLATE)?;
        println!("âœï¸  Created configuration file: {}", path.display());
        Ok(())
    }

    fn update_cargo_toml(&self, content: &str) -> Result<()> {
        // Check if [profile.dist] already exists
        if content.contains("[profile.dist]") {
            println!("â„¹ï¸  [profile.dist] already exists in Cargo.toml");
            return Ok(());
        }

        // Append profile.dist to Cargo.toml
        let profile_section = r#"
# Build profile for distribution
[profile.dist]
inherits = "release"
lto = "thin"
"#;

        let mut file = fs::OpenOptions::new()
            .append(true)
            .open("Cargo.toml")?;
        
        writeln!(file, "{}", profile_section)?;
        println!("âœï¸  Added [profile.dist] to Cargo.toml");

        Ok(())
    }

    fn generate_github_workflow(&self) -> Result<()> {
        let workflow_dir = PathBuf::from(".github/workflows");
        
        if !workflow_dir.exists() {
            fs::create_dir_all(&workflow_dir)?;
            println!("ðŸ“ Created .github/workflows directory");
        }

        let workflow_path = workflow_dir.join("release.yml");
        
        if workflow_path.exists() && !self.yes {
            if !self.confirm("Release workflow already exists. Overwrite?")? {
                println!("â­ï¸  Skipping workflow generation");
                return Ok(());
            }
        }

        fs::write(&workflow_path, RELEASE_WORKFLOW_TEMPLATE)?;
        println!("âœï¸  Created GitHub Actions workflow: {}", workflow_path.display());

        Ok(())
    }

    fn confirm(&self, prompt: &str) -> Result<bool> {
        if self.yes {
            return Ok(true);
        }

        print!("{} (y/N): ", prompt);
        io::stdout().flush()?;

        let mut input = String::new();
        io::stdin().read_line(&mut input)?;

        Ok(input.trim().eq_ignore_ascii_case("y"))
    }
}